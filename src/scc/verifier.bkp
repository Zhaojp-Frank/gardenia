// Copyright 2016, National University of Defense Technology
// Authors: Xuhao Chen <cxh@illinois.edu>
#include "scc.h"
#include "timer.h"
//#include <stdlib.h>
//#include <stdint.h>
//#include <utility>
#include <string.h>
#include <stack>
//#define BIT_SHIFT ((unsigned)1 << 31)

class TR_vertex {
	public:
		//unsigned visit;
		//unsigned low_link;
		//TR_vertex() : visit(0), low_link(0) {}
		//inline unsigned getVisited() { return visit; }
		//inline void setVisited(unsigned n) { visit = n; }
		//inline unsigned getLowLink() { return (low_link & 0x7FFFFFFF); }
		//inline void setLowLink(unsigned n) { low_link = (n | (low_link & BIT_SHIFT)); }
		//inline bool isInComponent () { return (low_link & BIT_SHIFT); }
		//inline void setInComponentBit() { low_link = (low_link | BIT_SHIFT); };
		//inline void clearInComponentBit() { low_link = (low_link & ~BIT_SHIFT); };
		int visit;
		int low_link;
		bool is_in_comp;
		TR_vertex() : visit(0), low_link(0), is_in_comp(0) {}
		inline int getVisited() { return visit; }
		inline void setVisited(int n) { visit = n; }
		inline int getLowLink() { return low_link; }
		inline void setLowLink(int n) { low_link = n; }
		inline bool isInComponent () { return is_in_comp; }
		inline void setInComponentBit() { is_in_comp = 1; };
		//inline void clearInComponentBit() { is_in_comp = 0; };
};

class TR_stack_vertex {
	public:
		//unsigned id;
		//unsigned from;
		//inline unsigned getId() { return (id & 0x7FFFFFFF); }
		//inline void setId(unsigned n) { id = (n | (id & BIT_SHIFT)); }
		//inline bool isExpanded () { return (id & BIT_SHIFT); }
		//inline void setExpandedBit() { id = (id | BIT_SHIFT); };
		//inline void clearExpandedBit() { id = (id & ~BIT_SHIFT); };
		//inline unsigned getFrom() { return from; }
		//inline void setFrom(unsigned n) { from = n ; }
		int id;
		int from;
		bool is_expanded;
		TR_stack_vertex() : id(-1), from(-1), is_expanded(0) {}
		inline int getId() { return id; }
		inline void setId(int n) { id = n; }
		inline bool isExpanded () { return is_expanded; }
		inline void setExpandedBit() { is_expanded = 1; };
		//inline void clearExpandedBit() { is_expanded = 0; };
		inline int getFrom() { return from; }
		inline void setFrom(int n) { from = n ; }
};

void tarjan_scc(int m, int *row_offsets, int *column_indices) {
	int number_of_SCC = 0;
	bool terminated = false;
	int trivial = 0;
	int non_trivial = 0;
	//for (int i = 0; i < m; i ++) printf("r[%d]=%d, ", i, row_offsets[i]); printf("\n");
	//for (int i = 0; i < 17; i ++) printf("c[%d]=%d, ", i, column_indices[i]); printf("\n");

	int *scc_root;
	scc_root = (int *)malloc(m * sizeof(int));
	//memset(scc_dist, 0, (m + 1) * sizeof(*scc_dist));
	int biggestSCC = 0;
	stack<TR_stack_vertex> visit_stack;
	stack<int> scc_stack;
	int scc_top;
	int time = 1;
	TR_stack_vertex stack_vertex;
	TR_vertex *mx = new TR_vertex[m];
	int iter = 0;
	Timer t;
	t.Start();
	//first initial states
	stack_vertex.setId(0);
	visit_stack.push(stack_vertex);
	do {
		if (iter < 10) printf("iteration=%d, stack_size=%ld\n", iter, visit_stack.size());
		iter ++;
		int inner_iter = 0;
		while ( !(visit_stack.empty()) ) {
			inner_iter ++;
			stack_vertex = visit_stack.top();
			visit_stack.pop();
			if ( ! stack_vertex.isExpanded() ) {
				if (mx[stack_vertex.getId()].getVisited() == 0) {//states hasn't been visited during DFS yet
					mx[stack_vertex.getId()].setVisited(time);
					mx[stack_vertex.getId()].setLowLink(time);
					time++;
					//if (inner_iter < 10 && iter < 10) printf("time=%d\n", time);
					scc_stack.push(stack_vertex.getId());
					stack_vertex.setExpandedBit();
					visit_stack.push(stack_vertex);
					//expand stack_vertex and push its successors into the stack
					for ( int column = row_offsets[ stack_vertex.getId() ]; column < row_offsets[ stack_vertex.getId() + 1 ]; column++ ) {
						TR_stack_vertex succ_stack_vertex;
						succ_stack_vertex.setId(column_indices[ column ]);
						succ_stack_vertex.setFrom(stack_vertex.getId());
						visit_stack.push(succ_stack_vertex);
					}
				}
				else {
					if ( ! mx[stack_vertex.getId()].isInComponent() ) {
						if ( mx[ stack_vertex.getFrom() ].getLowLink() > mx[stack_vertex.getId()].getVisited() ) {
							mx[ stack_vertex.getFrom() ].setLowLink(mx[stack_vertex.getId()].getVisited());
						}
					}
				}
			}
			else {
				// if DFN[v]=LOW[v], v is the root of a SCC
				if ( ( mx[ stack_vertex.getId() ].getVisited() == mx[ stack_vertex.getId() ].getLowLink() ) &&
						( ! mx[ stack_vertex.getId() ].isInComponent() ) ) {
					int scc_size = 0;
					// pop all the above virtices, and they consist of a SCC
					do {
						scc_top = scc_stack.top();
						scc_root[scc_top] = stack_vertex.getId();
						scc_stack.pop();
						mx[ scc_top ].setInComponentBit();
						scc_size++;
					} while ( scc_top != stack_vertex.getId() );
					number_of_SCC++;
					if (scc_size > biggestSCC)
						biggestSCC = scc_size;
					if (scc_size == 1) trivial++;
					else non_trivial++;
					//if (inner_iter< 10 && iter < 10) printf("iteration=%d, scc_size=%d\n", iter, scc_size);
				}// second condition due to initial states
				if ( ( ! mx[ stack_vertex.getId() ].isInComponent() ) && ( stack_vertex.getFrom() != -1 ) ) {
					if ( mx[ stack_vertex.getFrom() ].getLowLink() > mx[ stack_vertex.getId() ].getLowLink() ) {
						mx[ stack_vertex.getFrom() ].setLowLink( mx[ stack_vertex.getId() ].getLowLink());
					}
				}
			}
		}
		terminated = true;
		// turn to other DFS trees if still some vertices unvisited
		for (int i = 1; i < m; i++ ) {
			if ( mx[i].getVisited() == 0 ) {
				terminated = false;
				TR_stack_vertex stack_vertex;
				stack_vertex.setId(i);
				visit_stack.push(stack_vertex); 
				//cout <<" Seed = "<< i << endl;
				break;
			}
		}
	} while ( !terminated );
	t.Stop();
	printf("\tnum_trivial=%d, num_nontrivial=%d, biggest_scc_size=%d\n", trivial, non_trivial, biggestSCC);
	printf("\titerations = %d.\n", iter);
} 

void SCCVerifier(int m, int *in_row_offsets, int *in_column_indices, int *out_row_offsets, int *out_column_indices, int *color) {
	printf("Verifying...\n");
	Timer t;
	t.Start();
	tarjan_scc(m, out_row_offsets, out_column_indices);
	t.Stop();
	printf("\truntime [verify] = %f ms.\n", t.Millisecs());
	printf("Correct\n");
	return;
}

